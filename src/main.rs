use std::{cmp::max, ops::Neg};

use crate::file::BinFile;
use ::r1cs::{Bn128, Element, num::BigUint};

mod curves;
mod file;
mod ptau_file;
mod r1cs;
mod utils;

use crate::ptau_file::PTauFile;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let ptau_path = "src/artifacts/pot24.ptau";
    let r1cs_path = "src/artifacts/email_auth.r1cs";

    println!("Processing PTAU..");
    let (fd_ptau, sections_ptau) = file::read_bin_file(ptau_path, "ptau", 1).await?;

    let mut ptau_file = PTauFile::from(fd_ptau);

    let (curve, power, ceremony_power) = ptau_file.read_header(&sections_ptau).await?;
    println!(
        "Curve: {}, Power: {}, Ceremony Power: {}",
        curve.f1.n64, power, ceremony_power
    );

    let (mut fd_r1cs, sections_r1cs) = file::read_bin_file(r1cs_path, "r1cs", 1).await?;

    println!("Processing R1CS...");
    let mut r1cs = file::read_r1cs_fd(&mut fd_r1cs, &sections_r1cs).await?;
    println!("R1CS constraints: {}", r1cs.header.n_constraints);

    let s_g1 = curve.n8q * 2;
    let s_g2 = curve.n8q * 4;
    let n8r = curve.n8r;

    let s_r1cs = file::read_section(&mut fd_r1cs, &sections_r1cs, 2, None, None).await?;

    let plonk_n_vars = r1cs.header.n_vars;
    let n_public = r1cs.header.n_outputs + r1cs.header.n_pub_inputs;

    println!("Plonk n_vars: {}, n_public: {}", plonk_n_vars, n_public);
    println!("Processing constraints...");
    let (plonk_constraints, plonk_additions) = r1cs::process_constraints(&mut r1cs);

    // 1. Check if R1CS curve matches ptau curve prime
    if r1cs.header.prime != curve.r {
        eprintln!("‚ùå R1CS curve does not match PTAU curve");
        return Ok(());
    }

    let mut cir_power = ((plonk_constraints.len() - 1) as f64).log2().ceil() as u32;
    cir_power = max(cir_power, 3); // t polynomial requires at least power 3

    let domain_size = 1 << cir_power;

    println!("‚ÑπÔ∏è  Plonk constraints: {}", plonk_constraints.len());

    if cir_power > power {
        eprintln!(
            "‚ùå Circuit too big for this PTAU. 2**{} > 2**{} ({} constraints)",
            cir_power,
            power,
            plonk_constraints.len()
        );
        return Ok(());
    }

    // 4. Check if section 12 is present
    if !sections_ptau.contains_key(&12) {
        eprintln!("‚ùå PTAU file is not prepared (section 12 missing)");
        return Ok(());
    }

    println!("‚ÑπÔ∏è  R: {}", curve.r);
    println!("‚ÑπÔ∏è  Cir power: {}", cir_power);

    let (k1, k2) = get_k1_k2(&curve.r, cir_power);
    println!("‚ÑπÔ∏è  k1: {}, k2: {}", k1, k2);

    let mut fd_zkey = file::BinFile::create("output.zkey", "zkey", 1, 14).await?;
    write_additions(&mut fd_zkey, 3, "Additions", n8r, &plonk_additions).await?;

    Ok(())
}

/// Check if `k` is in the multiplicative cosets generated by `exponentiation` over the subgroup of size 2^pow.
fn is_included(
    k: &Element<Bn128>,
    existing: &[Element<Bn128>],
    pow: u32,
    step: &Element<Bn128>,
) -> bool {
    // domain_size = 2^pow
    let domain_size = 1u64 << pow;
    let mut w = Element::<Bn128>::one();

    for _ in 0..domain_size {
        if k == &w {
            return true;
        }
        for e in existing {
            if k == &(e.clone() * &w) {
                return true;
            }
        }
        w = &w * step;
    }
    false
}

/// Compute (k1, k2) such that neither lies in the cosets of powers-of-two subgroup collision.
///
/// # Arguments
/// * `r`   - The curve order (big integer) q.
/// * `pow` - The subgroup exponent s, so the domain size is 2^s.
pub fn get_k1_k2(r: &BigUint, pow: u32) -> (Element<Bn128>, Element<Bn128>) {
    // Basic field elements
    let one = Element::<Bn128>::one();
    let two = &one + &one;

    // 1) Find a non-quadratic residue `nqr`:
    //    We need nqr^((q-1)/2) == -1 in the field.
    let half = (r - BigUint::from(1u32)) >> 1;
    let mut nqr = two.clone();
    while nqr.exponentiation(&Element::from(half.clone())) != Element::<Bn128>::neg(one.clone()) {
        nqr = &nqr + &one;
    }

    // 2) Compute the step element: w = nqr^((q-1)/2^pow)
    let t = (r - BigUint::from(1u32)) >> pow as usize;
    let step = nqr.exponentiation(&Element::from(t));

    // 3) Find k1 starting from 2
    let mut k1 = two.clone();
    while is_included(&k1, &[], pow, &step) {
        k1 = &k1 + &one;
    }

    // 4) Find k2 starting from k1 + 1
    let mut k2 = &k1 + &one;
    while is_included(&k2, &[k1.clone()], pow, &step) {
        k2 = &k2 + &one;
    }

    (k1, k2)
}



pub trait ToMontgomeryBytes {
    fn as_montgomery_bytes(&self) -> Vec<u8>;
}

impl ToMontgomeryBytes for Element<Bn128> {
    fn as_montgomery_bytes(&self) -> Vec<u8> {
        self.to_biguint().to_bytes_le()
    }
}

pub async fn write_additions(
    fd: &mut BinFile,
    section_num: u32,
    name: &str,
    n8r: usize,
    plonk_additions: &[(u32, u32, Element<Bn128>, Element<Bn128>)],
) -> Result<(), anyhow::Error> {
    fd.start_write_section(section_num).await?;

    let mut buffer = vec![0u8; 2 * 4 + 2 * n8r];

    for (i, (a, b, v1, v2)) in plonk_additions.iter().enumerate() {
        let mut offset = 0;

        buffer[offset..offset + 4].copy_from_slice(&a.to_le_bytes());
        offset += 4;

        buffer[offset..offset + 4].copy_from_slice(&b.to_le_bytes());
        offset += 4;

        let v1_bytes = v1.as_montgomery_bytes();
        let v2_bytes = v2.as_montgomery_bytes();

        buffer[offset..offset + n8r].copy_from_slice(&v1_bytes[..n8r]);
        offset += n8r;

        buffer[offset..offset + n8r].copy_from_slice(&v2_bytes[..n8r]);

        fd.write_bytes(&buffer).await?;

        if i % 1_000 == 0 {
            println!("üîß Writing {name}: {}/{}", i, plonk_additions.len());
        }
    }

    fd.end_write_section().await?;

    Ok(())
}
