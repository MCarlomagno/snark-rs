use std::{cmp::max, ops::Neg, str::FromStr};

use crate::{big_buffer::BigBuffer, fft::FftEngine, file::BinFile};
use ::r1cs::{Bn128, Element, num::BigUint};
use anyhow::Result;

mod curves;
mod file;
mod ptau_file;
mod r1cs;
mod utils;
mod big_buffer;
mod fft;

use crate::ptau_file::PTauFile;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let ptau_path = "src/artifacts/pot24.ptau";
    let r1cs_path = "src/artifacts/email_auth.r1cs";

    println!("Processing PTAU..");
    let (fd_ptau, sections_ptau) = file::read_bin_file(ptau_path, "ptau", 1).await?;

    let mut ptau_file = PTauFile::from(fd_ptau);

    let (curve, power, ceremony_power) = ptau_file.read_header(&sections_ptau).await?;
    println!(
        "Curve: {}, Power: {}, Ceremony Power: {}",
        curve.f1.n64, power, ceremony_power
    );

    let (mut fd_r1cs, sections_r1cs) = file::read_bin_file(r1cs_path, "r1cs", 1).await?;

    println!("Processing R1CS...");
    let mut r1cs = file::read_r1cs_fd(&mut fd_r1cs, &sections_r1cs).await?;
    println!("R1CS constraints: {}", r1cs.header.n_constraints);

    let s_g1 = curve.n8q * 2;
    let s_g2 = curve.n8q * 4;
    let n8r = curve.n8r;

    let s_r1cs = file::read_section(&mut fd_r1cs, &sections_r1cs, 2, None, None).await?;

    let plonk_n_vars = r1cs.header.n_vars;
    let n_public = r1cs.header.n_outputs + r1cs.header.n_pub_inputs;

    println!("Plonk n_vars: {}, n_public: {}", plonk_n_vars, n_public);
    println!("Processing constraints...");
    let (plonk_constraints, plonk_additions) = r1cs::process_constraints(&mut r1cs);

    // 1. Check if R1CS curve matches ptau curve prime
    if r1cs.header.prime != curve.r {
        eprintln!("‚ùå R1CS curve does not match PTAU curve");
        return Ok(());
    }

    let mut cir_power = ((plonk_constraints.len() - 1) as f64).log2().ceil() as u32;
    cir_power = max(cir_power, 3); // t polynomial requires at least power 3

    let domain_size = 1 << cir_power;

    println!("‚ÑπÔ∏è  Plonk constraints: {}", plonk_constraints.len());

    if cir_power > power {
        eprintln!(
            "‚ùå Circuit too big for this PTAU. 2**{} > 2**{} ({} constraints)",
            cir_power,
            power,
            plonk_constraints.len()
        );
        return Ok(());
    }

    // 4. Check if section 12 is present
    if !sections_ptau.contains_key(&12) {
        eprintln!("‚ùå PTAU file is not prepared (section 12 missing)");
        return Ok(());
    }

    println!("‚ÑπÔ∏è  R: {}", curve.r);
    println!("‚ÑπÔ∏è  Cir power: {}", cir_power);

    // let (k1, k2) = get_k1_k2(&curve.r, cir_power);
    let k1 = Element::<Bn128>::from(2u64);
    let k2 = Element::<Bn128>::from(3u64);
    println!("‚ÑπÔ∏è  k1: {}, k2: {}", k1, k2);


    let mut fd_zkey = file::BinFile::create("output.zkey", "zkey", 1, 14).await?;
    write_additions(&mut fd_zkey, 3, "Additions", n8r, &plonk_additions).await?;

    write_witness_map(&mut fd_zkey, 4, &plonk_constraints, 0, "Amap").await?;
    write_witness_map(&mut fd_zkey, 5, &plonk_constraints, 1, "Bmap").await?;
    write_witness_map(&mut fd_zkey, 6, &plonk_constraints, 2, "Cmap").await?;

    let max_bits = (domain_size as f64).log2().ceil() as usize;
    let fft_engine = FftEngine::new(max_bits);

    write_q_map(&mut fd_zkey, 7, "Qm", n8r, domain_size, &plonk_constraints, 3, None, &fft_engine).await?;
    write_q_map(&mut fd_zkey, 8, "Ql", n8r, domain_size, &plonk_constraints, 4, None, &fft_engine).await?;
    write_q_map(&mut fd_zkey, 9, "Qr", n8r, domain_size, &plonk_constraints, 5, None, &fft_engine).await?;
    write_q_map(&mut fd_zkey, 10, "Qo", n8r, domain_size, &plonk_constraints, 6, None, &fft_engine).await?;
    write_q_map(&mut fd_zkey, 11, "Qc", n8r, domain_size, &plonk_constraints, 7, None, &fft_engine).await?;
    Ok(())
}

/// Check if `k` is in the multiplicative cosets generated by `exponentiation` over the subgroup of size 2^pow.
fn is_included(
    k: &Element<Bn128>,
    existing: &[Element<Bn128>],
    pow: u32,
    step: &Element<Bn128>,
) -> bool {
    // domain_size = 2^pow
    let domain_size = 1u64 << pow;
    let mut w = Element::<Bn128>::one();

    for _ in 0..domain_size {
        if k == &w {
            return true;
        }
        for e in existing {
            if k == &(e.clone() * &w) {
                return true;
            }
        }
        w = &w * step;
    }
    false
}

/// Compute (k1, k2) such that neither lies in the cosets of powers-of-two subgroup collision.
///
/// # Arguments
/// * `r`   - The curve order (big integer) q.
/// * `pow` - The subgroup exponent s, so the domain size is 2^s.
pub fn get_k1_k2(r: &BigUint, pow: u32) -> (Element<Bn128>, Element<Bn128>) {
    // Basic field elements
    let one = Element::<Bn128>::one();
    let two = &one + &one;

    // 1) Find a non-quadratic residue `nqr`:
    //    We need nqr^((q-1)/2) == -1 in the field.
    let half = (r - BigUint::from(1u32)) >> 1;
    let mut nqr = two.clone();
    while nqr.exponentiation(&Element::from(half.clone())) != Element::<Bn128>::neg(one.clone()) {
        nqr = &nqr + &one;
    }

    // 2) Compute the step element: w = nqr^((q-1)/2^pow)
    let t = (r - BigUint::from(1u32)) >> pow as usize;
    let step = nqr.exponentiation(&Element::from(t));

    // 3) Find k1 starting from 2
    let mut k1 = two.clone();
    while is_included(&k1, &[], pow, &step) {
        k1 = &k1 + &one;
    }

    // 4) Find k2 starting from k1 + 1
    let mut k2 = &k1 + &one;
    while is_included(&k2, &[k1.clone()], pow, &step) {
        k2 = &k2 + &one;
    }

    (k1, k2)
}



pub trait ToMontgomeryBytes {
    fn as_montgomery_bytes(&self) -> Vec<u8>;
}

impl ToMontgomeryBytes for Element<Bn128> {
    fn as_montgomery_bytes(&self) -> Vec<u8> {
        self.to_biguint().to_bytes_le()
    }
}

pub async fn write_additions(
    fd: &mut BinFile,
    section_num: u32,
    name: &str,
    n8r: usize,
    plonk_additions: &[(u32, u32, Element<Bn128>, Element<Bn128>)],
) -> Result<(), anyhow::Error> {
    fd.start_write_section(section_num).await?;

    for (i, (a, b, v1, v2)) in plonk_additions.iter().enumerate() {
        let mut buffer = vec![0u8; 2 * 4 + 2 * n8r];
        let mut offset = 0;
    
        buffer[offset..offset + 4].copy_from_slice(&a.to_le_bytes());
        offset += 4;
        buffer[offset..offset + 4].copy_from_slice(&b.to_le_bytes());
        offset += 4;
    
        let v1_bytes = to_n8r_bytes(&v1.as_montgomery_bytes(), n8r);
        let v2_bytes = to_n8r_bytes(&v2.as_montgomery_bytes(), n8r);
    
        buffer[offset..offset + n8r].copy_from_slice(&v1_bytes);
        offset += n8r;
        buffer[offset..offset + n8r].copy_from_slice(&v2_bytes);
    
        fd.write_bytes(&buffer).await?;
    
        if i % 1_000_000 == 0 {
            println!("üîß Writing {name}: {}/{}", i, plonk_additions.len());
        }
    }

    fd.end_write_section().await?;
    Ok(())
}

fn to_n8r_bytes(raw: &[u8], n8r: usize) -> Vec<u8> {
    let mut out = vec![0u8; n8r];
    let len = raw.len().min(n8r);
    out[..len].copy_from_slice(&raw[..len]);
    out
}

pub async fn write_witness_map(
    fd: &mut BinFile,
    section_num: u32,
    constraints: &[(u32, u32, u32, Element<Bn128>, Element<Bn128>, Element<Bn128>, Element<Bn128>, Element<Bn128>)],
    pos_constraint: usize,
    name: &str,
) -> Result<()> {
    fd.start_write_section(section_num).await?;

    for (i, constraint) in constraints.iter().enumerate() {
        let val = match pos_constraint {
            0 => constraint.0,
            1 => constraint.1,
            2 => constraint.2,
            _ => return Err(anyhow::anyhow!("Invalid pos_constraint index")),
        };
        fd.write_u32(val).await?;

        if i % 1_000_000 == 0 {
            println!("üëÅÔ∏è‚Äçüó®Ô∏è writing witness map {}: {}/{}", name, i, constraints.len());
        }
    }

    fd.end_write_section().await?;
    Ok(())
}

pub async fn write_q_map(
    fd: &mut BinFile,
    section_num: u32,
    name: &str,
    n8r: usize,
    domain_size: usize,
    plonk_constraints: &[(u32, u32, u32, Element<Bn128>, Element<Bn128>, Element<Bn128>, Element<Bn128>, Element<Bn128>)],
    pos_constraint: usize,
    logger: Option<&dyn Fn(&str)>,
    fft: &FftEngine,
) -> Result<BigBuffer> {
    let mut q_buffer = BigBuffer::new(domain_size * n8r);

    for (i, constraint) in plonk_constraints.iter().enumerate() {
        let elem = match pos_constraint {
            3 => &constraint.3,
            4 => &constraint.4,
            5 => &constraint.5,
            6 => &constraint.6,
            7 => &constraint.7,
            _ => panic!("Invalid pos_constraint index"),
        };

        let bytes = elem.to_biguint().to_bytes_le();
        let mut padded = vec![0u8; n8r];
        padded[..bytes.len()].copy_from_slice(&bytes);
        q_buffer.set(&padded, i * n8r);

        if i % 1_000_000 == 0 {
            if let Some(log) = logger {
                log(&format!("üåÄ writing {}: {}/{}", name, i, plonk_constraints.len()));
            }
        }
    }

    fd.start_write_section(section_num).await?;
    write_p4(fd, &q_buffer, domain_size, n8r, fft).await?;
    fd.end_write_section().await?;

    Ok(q_buffer)
}

pub async fn write_p4(
    fd: &mut BinFile,
    input: &BigBuffer,
    domain_size: usize,
    n8r: usize,
    fft: &FftEngine,
) -> Result<()> {
    // Deserialize into Vec<Element<Bn128>>
    let q: Vec<Element<Bn128>> = (0..domain_size)
        .map(|i| {
            let bytes = input.slice(i * n8r, (i + 1) * n8r);
            let num = BigUint::from_bytes_le(&bytes);
            Element::<Bn128>::from_str(&num.to_string()).unwrap()
        })
        .collect();

    let q_ifft = fft.ifft(&q);
    let mut q4_input = vec![Element::<Bn128>::zero(); domain_size * 4];
    q4_input[..domain_size].clone_from_slice(&q_ifft);

    let q4_fft = fft.fft(&q4_input);

    // Write q_ifft
    for elem in &q_ifft {
        let bytes = elem.to_biguint().to_bytes_le();
        let mut padded = vec![0u8; n8r];
        padded[..bytes.len()].copy_from_slice(&bytes);
        fd.write_bytes(&padded).await?;
    }

    // Write q4_fft
    for elem in &q4_fft {
        let bytes = elem.to_biguint().to_bytes_le();
        let mut padded = vec![0u8; n8r];
        padded[..bytes.len()].copy_from_slice(&bytes);
        fd.write_bytes(&padded).await?;
    }

    Ok(())
}